package ca.ostrowski.limon;

import org.apache.commons.io.FilenameUtils;
import retrofit2.Call;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;
import retrofit2.http.GET;
import retrofit2.http.Query;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.*;
import java.util.*;

import static spark.Spark.get;
import static spark.Spark.staticFiles;

public class App {
    static String url = "http://www.omdbapi.com/";

    public static class Movie {
        public String imdbID;
        public String Title;
        public String Year;
        public String Genre;
        public String Director;
        public String Actors;
        public String Plot;
        public String Poster;
        public String Path;


        public Movie(String imdbID, String title, String year, String genre, String director,
                     String actors, String plot, String poster, String path) {
            this.imdbID = imdbID;
            Title = title;
            Year = year;
            Genre = genre;
            Director = director;
            Actors = actors;
            Plot = plot;
            Poster = poster;
            Path = path;
        }

        @Override
        public String toString() {
            return "Movie{" +
                    "imdbID='" + imdbID + '\'' +
                    ", Title='" + Title + '\'' +
                    ", Year='" + Year + '\'' +
                    ", Genre='" + Genre + '\'' +
                    ", Director='" + Director + '\'' +
                    ", Actors='" + Actors + '\'' +
                    ", Plot='" + Plot + '\'' +
                    ", Poster='" + Poster + '\'' +
                    ", Path='" + Path + '\'' +
                    '}';
        }
    }

    public interface OMDb {
        @GET("/")
        Call<Movie> movie(
                @Query("t") String title
        );
    }

    static OMDb omdb = null;
    static Connection connection = null;

    public static void main(String[] args) throws IOException {
        //Root directory to search for movies
        List<String> moviesFound = App.directorySearch("/home/savannah/Documents/code/limon/");

        //Create REST adapter which points to OMDb API
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(url)
                .addConverterFactory(GsonConverterFactory.create())
                .build();
        //secret subclass of OMDb generated by retrofit
        omdb = retrofit.create(OMDb.class);

        // get json for the movies found in the directories
        List<Movie> moviesJson = getMovieInfo(moviesFound);

        try {
            //open sqlite db connection
            connection = DriverManager.getConnection("jdbc:sqlite:/home/savannah/Documents/code/limon/movies.db");
            Statement statement = connection.createStatement();
            statement.setQueryTimeout(30);
            System.out.println("Connected to DB successfully");

            statement.executeUpdate("DROP TABLE IF EXISTS movies");
            statement.executeUpdate("CREATE TABLE movies (imdbID CHAR(20), Title CHAR(50), " +
                    "Year CHAR(50), Genre CHAR(50), Director CHAR(50), Actors CHAR(255)," +
                    "Plot VARCHAR(500), Poster CHAR(100), Path CHAR(500))");
            System.out.println("DB created");


            dbInsert(moviesJson);
            System.out.println("DB populated");

            String orderSQLStatement = "SELECT * FROM movies ORDER BY Title;";
            ResultSet rs = statement.executeQuery(orderSQLStatement);

            ArrayList<Movie> movieOutput = convertResultSetToArrayList(rs);
            System.out.println(Arrays.toString(movieOutput.toArray()));
        } catch (SQLException e) {
            // if the error message is "out of memory",
            // it probably means no database file is found
            System.err.println(e.getMessage());
        } finally {
            try {
                //if there already exists a connection
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                //connection close failed
                System.err.println(e);
            }

        }
        staticFiles.location("/frontend");
        get("/", (req, res) -> "");

    }

    private static Set<String> movieExtensions = new HashSet<>(Arrays.asList("mp4", "avi", "mkv", "webm", "mov", "wmv",
            "m4p", "m4v", "mpg", "mp2", "mpeg", "mpe", "mpv", "m2v"));

    static List<String> paths;

    public static List<String> directorySearch(String rootDir) throws IOException {
        List<String> movies = new ArrayList<>();
        paths = new ArrayList<>();
        Files.walk(Paths.get(rootDir)).forEach(filePath -> {
            if (!Files.isRegularFile(filePath)) {
                return;
            }
            String ext = FilenameUtils.getExtension(filePath.toString());
            for (String extensionInstance : movieExtensions) {
                if (ext.equals(extensionInstance)) {
                    movies.add(FilenameUtils.getBaseName(filePath.toString()));
                    paths.add(filePath.toString());
                }
            }
        });
        return movies;
    }

    public static List<Movie> getMovieInfo(List<String> movies) throws IOException {
        List<Movie> moviesJson = new ArrayList<>();
        for (String film : movies) {
            Movie m = omdb.movie(film).execute().body();
            moviesJson.add(m);
        }
        return moviesJson;
    }

    public static String quote(String s) throws IOException {
        return "'" + s + "'";
    }

    // need to insert paths to movies
    public static void dbInsert(List<Movie> moviesJson) throws IOException, SQLException {
        for (Movie filmJson : moviesJson) {
            String CurrentMoviePath = null;
            for (int i = 0; i < paths.size(); i++) {
                String movieName = FilenameUtils.getBaseName(paths.get(i));
                if (movieName.equals(filmJson.Title)) {
                    System.out.println("Inserting the movie: " + movieName);
                    CurrentMoviePath = paths.get(i);
                    break;
                }
            }

            String sqlStatement = "INSERT INTO movies VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?)";
            PreparedStatement statement = connection.prepareStatement(sqlStatement);
            statement.setString(1, filmJson.imdbID);
            statement.setString(2, filmJson.Title);
            statement.setString(3, filmJson.Year);
            statement.setString(4, filmJson.Genre);
            statement.setString(5, filmJson.Director);
            statement.setString(6, filmJson.Actors);
            statement.setString(7, filmJson.Plot);
            statement.setString(8, filmJson.Poster);
            statement.setString(9, CurrentMoviePath);
            statement.executeUpdate();
        }
    }

    public static Movie createMovie(ResultSet rs) {
        ArrayList<String> temp = new ArrayList<>();
        for (int i = 1; i <= 9; i++) {
            try {
                temp.add(rs.getString(i));
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        Movie m = new Movie(temp.get(0), temp.get(1), temp.get(2), temp.get(3), temp.get(4),
                temp.get(5), temp.get(6), temp.get(7), temp.get(8));
        return m;
    }

    public static ArrayList<Movie> convertResultSetToArrayList(ResultSet rs) {
        ArrayList<Movie> output = new ArrayList<>();
        try {
            while(rs.next()) {
                Movie temp = createMovie(rs);
                output.add(temp);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return output;
    }
}

